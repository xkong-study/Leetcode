### 数学公式解释

二分查找的核心思想是在每一步都将搜索范围减半。我们可以使用数学公式来描述这个过程。

#### 前言背景
想象一下你正在阅读一本非常厚的小说，这本小说按页码顺序排列，你想找到第500页。但是，你不知道这本书的具体页数，只知道它有1000页。

二分查找就像这样：

1. **首先**，你直接翻到这本书的中间，也就是第500页。
2. **如果**你恰好找到了你想要的页码，那么任务完成。
3. **如果**第500页不是你想要的，你会看这是第490页，这意味着你想要的第500页在后面。于是，你忽略了前490页，现在只关注491页到1000页之间。
4. **接着**，你再次翻到这个新范围的中间，也就是第745页。你发现这太多了，所以你现在知道第500页在491页和745页之间。
5. **你继续**这样做，每次都将搜索范围减半，直到找到第500页。

这就是二分查找的工作原理。每次都将搜索范围减半，这使得查找非常快速，尤其是在大数据集中。


### 数学逻辑
假设我们有一个已排序的数组 *A*，长度为  *n*，我们想要查找的目标值是 *x*。

1. 定义两个指针：left 和 right，初始时，left=0 和 right=*n*−1。
2. 在每一步，我们计算中间索引 mid： mid=⌊left+right⌋/2
3. 我们比较 A[mid]和 x：
   - 如果 `A[mid]` 等于 `x`，则我们找到了目标值，返回 `mid`。
   - 如果 `A[mid]` 小于 `x`，那么 `x` 必定在 `mid` 的右侧，所以我们更新 `left` 为 `mid + 1`。
   - 如果 `A[mid]` 大于 `x`，那么 `x` 必定在 `mid` 的左侧，所以我们更新 `right` 为 `mid - 1`。
4. 如果 left 超过 right，则搜索结束，*x* 不在数组中。

这个算法的时间复杂度是O*(log2 n)，因为在每一步，我们都将搜索范围减半。



### 边缘条件

在二分查找中，`left <= right` 的条件确保了数组中的每一个元素都被考虑到。让我们详细分析为什么这是必要的：

1. **当 `left = right` 时**：这意味着我们的搜索范围已经缩小到数组中的一个单独的元素。如果我们不检查这种情况（即如果我们只使用 `left < right`），那么当搜索范围缩小到一个元素时，我们将跳过这个元素，可能会错过目标值。
2. **当 `left < right` 时**：这是二分查找的正常情况，我们的搜索范围包括多个元素。
3. **当 `left > right` 时**：这意味着我们的搜索范围已经为空，即目标值不在数组中。

使用 `left <= right` 作为循环条件确保了当搜索范围缩小到一个元素时，我们仍然会检查这个元素。如果我们不这样做，那么在某些情况下，我们可能会错过目标值。

例如，考虑一个只有一个元素的数组 `[5]`，并且我们要查找的目标值是 `5`。如果我们使用 `left < right` 作为循环条件，那么我们将不会检查这个唯一的元素，从而错过目标值。但是，如果我们使用 `left <= right`，那么我们会正确地检查这个元素并找到目标值。



### 时间复杂度

二分查找的时间复杂度为O*(log*n) 是因为在每一步中，我们都将搜索范围减半。让我们详细分析这个过程：

1. **初始步骤**：我们开始时的搜索范围是整个数组，大小为 *n*。
2. **第一次迭代**：我们查找数组的中间元素并将搜索范围减半。现在的搜索范围大小为 n/2。
3. **第二次迭代**：我们再次查找新搜索范围的中间元素并将搜索范围减半。现在的搜索范围大小为*n*/4。
4. **第三次迭代**：搜索范围变为 *n*/8，依此类推。

这个“减半”的过程会持续进行，直到搜索范围缩小到1或0。

问题是：这个“减半”的过程需要进行多少次才能从 *n* 减少到 1？

答案是log2*n*。这是因为如果你连续地将一个数除以2，那么你需要除 log2*n* 次才能将这个数减少到1。

因此，二分查找的时间复杂度为O*(log*n*)，这意味着在最坏的情况下，我们需要 log*n 步才能找到目标元素或确定它不在数组中。

```javaScript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        let mid = Math.floor((left + right) / 2);

        if (arr[mid] === target) {
            return mid; // 返回目标元素的索引
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1; // 如果没有找到目标元素，返回-1
}

// 示例
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
console.log(binarySearch(numbers, 5)); // 输出: 4
console.log(binarySearch(numbers, 11)); // 输出: -1

```
