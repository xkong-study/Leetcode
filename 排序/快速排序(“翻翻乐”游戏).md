快速排序就像玩“翻翻乐”游戏，每次选择一个卡片作为参照，将数字小于它的卡片放左边，大于它的放右边，然后继续在左右两堆卡片中重复这个游戏，直到所有卡片都被正确地排序。

```javaScript
function quickSort(arr) {
    if (arr.length <= 1) return arr;

    let pivot = arr[arr.length - 1];
    let left = [];
    let right = [];

    for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }

    return [...quickSort(left), pivot, ...quickSort(right)];
}

```

**平均情况**：虽然具体的分析相对复杂，但通过概率和期望的计算，可以得出快速排序的平均时间复杂度也是 **O(n log n)**。

想象一下你正在玩一个猜数字的游戏，数字范围是从1到100。每次你猜一个数字，对方会告诉你你猜的数字是太大、太小还是正确。

如果每次你都选择中间的数字来猜（例如，首先猜50，然后如果太大就猜25，如果还是太大就猜12，以此类推），那么你最多需要猜多少次才能猜中正确的数字？

答案是7次。因为100可以被两分7次直到结果小于1（100, 50, 25, 12.5, 6.25, 3.125, 1.56, 0.78）。

这就是为什么我们说递归深度是log₂ n。
