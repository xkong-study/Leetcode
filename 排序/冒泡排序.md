### 原理：

冒泡排序就像气泡一样，大的数慢慢浮到上面，小的数沉到下面。通过不断地比较和交换，直到所有的数都排好序。

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 时间复杂度：

- **最好情况**：当输入的数据已经是排序好的情况下，冒泡排序只需要进行 n-1 次比较，不需要交换，所以最好情况的时间复杂度是 **O(n)**。
- **最坏情况**：当输入的数据是反序时，需要进行 n(n-1)/2 次比较和交换，所以最坏情况的时间复杂度是 **O(n^2)**。
- **平均情况**：在平均情况下，时间复杂度也是 **O(n^2)**。

现在，让我们详细分析冒泡排序的比较和交换次数：

1. 在第一次遍历中，我们比较第1个和第2个元素、第2个和第3个元素、...、第n-1个和第n个元素。这是 n-1 次比较（和可能的交换）。
2. 在第二次遍历中，由于最大的元素已经在最后的位置，我们只需要比较前 n-1 个元素。这次我们进行 n-2 次比较。
3. 在第三次遍历中，我们比较前 n-2 个元素，进行 n-3 次比较。
4. 以此类推，直到最后一次遍历，我们只进行1次比较。

因此，总的比较次数是： (*n*−1)+(*n*−2)+...+2+1

这是一个等差数列的和，其公式为：*n*(*n*−1)/2

所以，冒泡排序的最坏情况和平均情况下需要进行 *n*(*n*−1)/2次比较和交换。


```javaScript

function bubbleSort(arr) {
    let length  = arr.length - 1;
    for (let i = 0; i < length; i++) {
        for (let j = 0; j < length - i; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}

```

**代码解释**
i：代表已经完成排序的轮数
j：在每一轮排序中，j用于遍历数组并进行相邻元素的比较和可能的交换。
