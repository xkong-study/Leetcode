"原地哈希" 是一种算法和数据结构技巧，用于在不使用额外空间的情况下，对数据进行哈希操作或重新排列。通常，这种技巧用于解决涉及数组或链表等数据结构的问题，其中要求在不占用额外内存的情况下修改数据。

以下是一个力扣题目的示例，其中使用了原地哈希的思想：

**题目：**

**[LeetCode 41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)**

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

**示例 1:**

输入: nums = [1,2,0] 输出: 3

**示例 2:**

输入: nums = [3,4,-1,1] 输出: 2

**示例 3:**

输入: nums = [7,8,9,11,12] 输出: 1

在这个问题中，我们需要找到没有出现在给定数组中的最小正整数。我们可以使用原地哈希的思想来解决这个问题。具体做法如下：

1. 遍历数组，将所有小于等于 0 的数和大于数组长度的数都替换为数组长度 + 1（这是因为最小正整数不会大于数组长度）。
2. 再次遍历数组，将每个正整数对应的索引位置标记为负数，表示这个正整数已经出现过。
3. 最后，再次遍历数组，找到第一个正数对应的索引位置，这个索引位置就是缺失的最小正整数。

这个算法是原地哈希的一个典型示例，因为它没有使用额外的空间，而是直接在输入数组上进行操作，找到缺失的最小正整数。



这是鸽巢原理，解释索引和数据之间的关系。

```javaScript
对于数组中的每个数字 num：
    abs_num = 绝对值(num)
    如果 abs_num 在 1 到 n 的范围内：
        将索引 abs_num-1 的位置上的数字变为负数

```

我理解之后写的
```javaScript
var firstMissingPositive = function(nums) {
    for(let i = 0; i < nums.length; i++) {
        let index = Math.abs(nums[i]) - 1;
        if (index >= 0 && index < nums.length) {
            nums[index] = -Math.abs(nums[index]);
        }
    }

    for(let i = 0; i < nums.length; i++) {
        if(nums[i] >= 0) {
            return i + 1;
        }
    }

    return nums.length + 1;
};
```

```javaScript
正确答案: 我缺少了判读为负数的情况

var firstMissingPositive = function(nums) {
    // 将所有负数和零替换为一个大于数组长度的数
    for(let i = 0; i < nums.length; i++) {
        if(nums[i] <= 0) {
            nums[i] = nums.length + 1;
        }
    }

    for(let i = 0; i < nums.length; i++) {
        let index = Math.abs(nums[i]) - 1;
        if (index >= 0 && index < nums.length) {
            nums[index] = -Math.abs(nums[index]);
        }
    }

    for(let i = 0; i < nums.length; i++) {
        if(nums[i] >= 0) {
            return i + 1;
        }
    }

    return nums.length + 1;
};

```

这个算法的核心思想是基于数组的索引与值之间的关系，而不是传统的数学公式。但我们可以尝试从数学的角度来描述这个问题和其解决方案。

1. **定义域与值域**：考虑一个函数 *f*，其中 *f*(*i*) 表示数组在索引 *i* 的值。我们的目标是找到最小的正整数 *x*，使得 *x* 不在 *f* 的值域中。
2. **鸽巢原理**：如果有 *n* 个鸽巢和 *n*+1 只鸽子，至少有一个鸽巢有两只鸽子。在这个问题中，如果数组中的所有数字都在 1 到 *n* 的范围内，那么答案是 *n*+1。否则，答案是在 1 到 *n* 范围内的某个数字。
3. **映射与标记**：我们尝试将每个数字 x* 映射到索引 *x*−1。通过将索引 *x*−1 的值变为负数，我们可以标记数字 *x* 已经出现。这样，我们可以通过检查一个值的符号来确定对应的数字是否出现。
4. **绝对值与原始数据**：尽管我们修改了数组的某些值（将它们变为负数来标记），我们仍然可以通过取绝对值来获取原始的数字。

所以，这个算法的数学基础是基于定义域与值域的关系、鸽巢原理、映射与标记以及绝对值与原始数据的关系。虽然这不是一个传统的数学公式，但它确实提供了一个数学框架来理解这个问题和其解决方案。




1. **最大可能的缺失正整数**：对于长度为 n 的数组，最大可能的缺失正整数是 n+1。这是因为，即使数组包含了从 1 到 n 的所有整数，n+1 仍然是缺失的。
2. **数组索引与值的对应关系**：我们希望建立一个关系，使得数字 i 出现在索引 i-1 的位置。这样，我们可以通过检查索引来确定一个数字是否出现。
3. **标记已存在的数字**：为了跟踪哪些数字已经出现过，我们使用正负符号作为标记。如果数字 i 出现，我们将索引 i-1 的值变为负数。这样，我们可以通过检查一个值的符号来确定对应的数字是否出现。
4. **确定缺失的正整数**：在标记过程结束后，第一个正数的位置对应的数字就是第一个缺失的正整数。如果数组中的所有数字都是负数，那么 n+1 就是第一个缺失的正整数。
