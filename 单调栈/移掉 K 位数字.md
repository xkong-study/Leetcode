### 难点

我觉得单调栈的题目难点在于题目和单调栈关联不起来，不知道怎么用单调栈解题，一旦我知道这道题就是单调递增栈大的数字放在后面这道题就很简单。
我的写法:

```javaScript
var removeKdigits = function(num, k) {
let stack = []
for(let i=0;i<num.length;i++){
  while(stack.length && num[i]<num[stack[stack.length-1]] && k>0){
    stack.pop()
    k--
  }
  stack.push(i)
}
for(let i=0;i<stack.length;i++){
  stack[i] = num[stack[i]]
}
stack.splice(-k,k)
return Number(stack.join("")).toString()
};
```

但是提交之后34/43
对于num过长的代码时间超时了。

### 解决方法

但是我把 return Number(stack.join("")).toString()改成 return stack.join('').replace(/^0+/, '') || '0';就没问题了

### 原因

这两种方法在处理大数字时的性能差异导致了这种情况。

1. **`stack.join('').replace(/^0+/, '') || '0'`**:

   - `join('')`: 将数组的所有元素连接成一个字符串。
   - `replace(/^0+/, '')`: 使用正则表达式删除字符串前面的所有零。
   - `|| '0'`: 如果结果是空字符串（例如，当输入是 `"0000"`），则返回 `'0'`。

   这种方法直接在字符串上操作，不涉及数字转换。

2. **`Number(stack.join("")).toString()`**:

   - `stack.join("")`: 将数组的所有元素连接成一个字符串。
   - `Number(...)`: 将字符串转换为数字。这里可能会遇到性能问题，特别是当处理非常大的数字时。
   - `toString()`: 将数字转回字符串。

   当数字非常大时（超过 JavaScript 可以准确表示的范围），`Number` 的转换可能会变得非常慢，甚至可能导致不准确的结果。

因此，直接在字符串上操作（如第一种方法）通常更快，也更可靠，特别是当处理大数字时。

### 正则写法知识点扩充

**想象正则表达式就像一个"文本过滤器"**。你有一个筛子（正则表达式），你将文本倒入筛子中，筛子会根据你设置的规则（模式）来筛选出你想要的文本。

- **基本匹配**：就像筛子上有一个形状，只有这个形状的物品可以通过。
- **元字符**：特殊的形状，如数字的形状 `\d`。
- **量词**：决定形状可以出现的次数，如 `\d{3}` 表示三个数字的形状。
- **字符类**：一组形状，如 `[aeiou]` 是五个元音的形状。
- **锚点**：确定形状的位置，如 `^Hello` 表示筛子的顶部应该是 "Hello"。
- **分组和捕获**：将几个形状放在一起，并捕获它们。
- **选择**：选择一个形状或另一个形状，如 `apple|banana`。
- **转义字符**：当你真的想要一个点的形状，而不是任何形状，你使用 `\.`。
- **前后查找**：查看形状前后是否有特定的其他形状。
