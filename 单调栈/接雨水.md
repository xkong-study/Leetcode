单调栈在某种程度上确实与高等数学中的单调性有关。在高等数学中，我们利用函数的单调性来确定其极值（最大值和最小值）以及其他性质。同样地，单调栈也是基于单调性来解决某些问题的。
所以单调栈有两个性质：

1.单调性 --- 求极值

2.空间性（后进先出）---解决下雨等找空间相关的数据。

每次遍历凹槽都是单调栈里面最小的元素，所以每次遍历的都是以凹槽为最底部的雨水量，这个对空间数据结构的思考力度要求很高。

**也是用单调递减栈找右边的最大值通过找到凹槽，枚举一个个凹槽求和**

[!image](https://i.ibb.co/mBP8pQf/Screenshot-2023-10-18-at-13-58-29.png)

具体来说：

1. **高等数学中的单调性**：
   - 当我们知道一个函数在某个区间上是单调递增或递减的，我们可以很容易地确定它在该区间上的最大值和最小值。
   - 单调性还可以帮助我们确定函数的增减性，从而帮助我们理解函数的形状和行为。
2. **单调栈**：
   - 单调栈是一种数据结构，它保持栈中元素的单调性（递增或递减）。
   - 利用单调栈，我们可以有效地找到数组中每个元素的下一个更大（或更小）的元素。
   - 单调栈常用于解决与数组中元素的相对大小和位置有关的问题，如“接雨水”、“下一个更大元素”等。
     
我的错误写法：
```javaScript
var trap = function(height) {
let res = new Array(height.length).fill(0)
let stack = []
for(let i=0;i<height.length;i++){
    if(height[i]==0) i++
    while(stack.length&& height[i]>height[stack[stack.length-1]]){
        let j = stack.pop()
        res[j] = height[i] - height[j]
    }
    stack.push(i)
}
console.log(res)
};
```

正确写法：
```javaScript
function trap(height) {
    let result = 0;
    const stack = [];

    for (let i = 0; i < height.length; i++) {
        while (stack.length && height[i] > height[stack[stack.length - 1]]) {
            const top = stack.pop();
            if (!stack.length) break;
            const width = i - stack[stack.length - 1] - 1;
            const waterHeight = Math.min(height[i], height[stack[stack.length - 1]]) - height[top];
            result += width * waterHeight;
        }
        stack.push(i);
    }

    return result;
}

```

**解题思路**
这道题是通过用单调栈找到凹槽然后也获得了右边墙壁的高度 接着我们获取左边墙壁的高度

举个例子：
对于height = [0,1,0,2,1,0,1,3,2,1,2,1]：

当i = 1时，墙的高度为1，将索引1压入栈。 

当i = 2时，墙的高度为0，将索引2压入栈。 

当i = 3时，墙的高度为2，这时比栈顶的墙（索引2，高度0）高，所以索引2被弹出。然后，新的栈顶是索引1，其高度为1，也比当前墙的高度低，所以索引1也被弹出。此时栈为空，所以跳出while循环。然后将索引3压入栈。

当i = 4时，墙的高度为1，将索引4压入栈。 

当i = 5时，墙的高度为0，将索引5压入栈。

当i = 6时，墙的高度为1，将索引6压入栈。 

当i = 7时，墙的高度为3。这时，它会连续弹出索引6、5、4。当弹出索引4后，新的栈顶是索引3，其高度为2，比当前墙的高度低。所以，索引3也被弹出。此时栈为空，所以跳出while循环。然后将索引7压入栈。 

所以，索引为3的墙是在i = 7时被弹出的，因为此时遇到了一个高度为3的墙，它比索引3处的墙的高度高。 


**能不能用数学方法证明单调栈确实可以遍历获取所有的雨水量**

使用单调栈解决“接雨水”问题的正确性可以通过直观的方法来理解，但要形式化地使用数学方法进行证明是相对复杂的。不过，我们可以尝试提供一个简化的证明来解释为什么这种方法是有效的。

**基本思路**：

1. **单调性**：单调递减栈确保了栈顶的墙总是最矮的，而栈底的墙是迄今为止遇到的最高的。这意味着，如果我们遇到一个新的墙，这个墙比栈顶的墙高，那么这两堵墙之间一定可以积水。
2. **完整性**：由于我们遍历整个墙的高度数组，并将每堵墙的索引都压入栈中，我们可以确保处理每个可能的凹槽。当我们遇到一个新的高墙并开始弹出栈中的墙时，我们会处理所有与这个新墙相关的凹槽。

**证明**：

1. **单调性保证了凹槽的存在**：由于栈是单调递减的，所以当我们遇到一个新的墙，这个墙比栈顶的墙高，这意味着这两堵墙之间一定存在一个凹槽。这个凹槽的深度是由这两堵墙的高度差和其他在它们之间的墙的高度决定的。
2. **完整性保证了所有凹槽都被处理**：由于我们遍历整个墙的高度数组，并将每堵墙的索引都压入栈中，我们可以确保处理每个可能的凹槽。当我们遇到一个新的高墙并开始弹出栈中的墙时，我们会处理所有与这个新墙相关的凹槽。
3. **雨水量的计算是准确的**：对于每个凹槽，我们都可以准确地计算其宽度和深度，从而得到其雨水量。宽度是两堵墙之间的距离，深度是两堵墙的高度差和凹槽底部的高度之间的差值。

综上所述，我们可以得出结论，使用单调栈的方法可以确保我们准确地计算了整个墙的高度数组中的所有雨水量。

****数学公式****

**定义**： 让 `H` 代表墙的高度数组，其中 `H[i]` 是第 `i` 堵墙的高度。让 `S` 代表一个单调递减的栈，这个栈存储墙的索引。

**证明**：

1. 由于 `S` 是单调递减的，所以对于任意的 `i < j`，我们都有 `H[S[i]] >= H[S[j]]`。
2. 当我们遇到一个新的墙，表示为 `H[k]`，如果 `H[k] > H[S[j]]`，那么这意味着存在一个凹槽。
3. 这个凹槽的宽度定义为 `W = k - S[i] - 1`。
4. 凹槽的深度定义为 `D = min(H[k], H[S[i]]) - H[S[j]]`。
5. 雨水量计算为 `V = W * D`。

总结：通过遍历整个 `H` 并处理每个凹槽，我们可以得到总雨水量为所有 `V` 之和。

