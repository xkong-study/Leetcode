这道题是单调递增栈，接雨水问题是单调递减栈。

我的错误代码能对20/98
```javaScript
var largestRectangleArea = function(heights) {
let max = 0
let stack = []
if(heights.length == 1) return heights[0]
for(let i=0;i<heights.length;i++){
   while(stack.length){
       let j = stack.pop()
       let width = i - j + 1
       let height = Math.min(heights[i],heights[j]) 
       max = Math.max(max,width*height)
   }
   stack.push(i)
}
return max;
};
```
正确代码
```javaScript
var largestRectangleArea = function(heights) {
    let max = 0;
    let stack = [];
    for(let i = 0; i <= heights.length; i++) {
        while(stack.length && (i == heights.length || heights[i] < heights[stack[stack.length - 1]])) {
            let j = stack.pop();
            let width = stack.length ? i - stack[stack.length - 1] - 1 : i;
            max = Math.max(max, width * heights[j]);
        }
        stack.push(i);
    }
    return max;
};

```

使用单调递增栈求“柱状图中最大的矩形”问题的最大面积的原因基于以下几点：

1. **目标**：我们的目标是找到每根柱子的左右边界，这样我们就可以计算以该柱子为高的矩形的最大面积。
2. **右边界的确定**：当我们遍历到一个新的柱子，并且这个柱子的高度小于栈顶柱子的高度时，这意味着我们找到了栈顶柱子的右边界。因为在一个单调递增的序列中，一个更矮的柱子会打破这种单调性，这意味着前面的柱子（即栈顶的柱子）无法再向右扩展。
3. **左边界的确定**：由于栈是单调递增的，所以当我们从栈中弹出柱子时，新的栈顶柱子就是该柱子的左边界。这是因为新的栈顶柱子是小于或等于当前柱子的，这意味着当前柱子可以向左扩展到新的栈顶柱子的位置。
4. **计算面积**：一旦我们确定了柱子的左右边界，我们就可以计算以该柱子为高的矩形的面积。面积 = 高度 x 宽度。这里的高度是柱子的高度，宽度是右边界和左边界之间的距离。
5. **为什么有效**：单调递增栈确保我们总是在遇到一个更矮的柱子时处理栈中的柱子。这样，我们可以确保每根柱子都被考虑，且只被考虑一次。
6. **完整性**：在遍历结束后，栈中可能还有一些柱子。这些柱子的右边界是数组的末尾，左边界是栈中的前一个柱子。我们需要继续处理这些柱子以确保考虑所有可能的矩形。

通过这种方式，单调递增栈帮助我们有效地找到每根柱子的左右边界，并计算出以该柱子为高的矩形的最大面积，从而找到整个柱状图中的最大矩形面积。

**为什么这种方法可以找到最大面积**

- 对于每根柱子，我们都确定了它的左右边界，并计算了以此柱子为高度的矩形的面积。

- 由于我们考虑了所有的柱子，我们实际上考虑了所有可能的矩形。这确保了我们找到的最大面积是全局最大的。

- 单调栈的特性确保了我们在确定每根柱子的左右边界时是高效的。我们不需要为每根柱子都重新遍历数组来确定其边界。

  

使用数学方法直接证明单调栈的有效性可能会有些复杂，但我们可以通过逻辑和直观的方式来理解为什么这种方法是有效的。以下是一个尝试：

1. **定义**：
   - 设 h*[*i*] 为第 i* 根柱子的高度。
   - 设*l*[*i*] 和*r*[*i*] 分别为第 *i* 根柱子的左边界和右边界。
2. **面积计算**：
   - 对于第 *i* 根柱子，其对应的矩形面积为 h*[*i*]×(*r*[*i*]−*l*[*i]+1)。
3. **单调性的意义**：
   - 当我们遍历柱子并使用单调递增栈时，栈顶的柱子总是当前遇到的最高柱子。这意味着，只要我们遇到一个比栈顶柱子矮的柱子，我们就可以确定栈顶柱子的右边界。
   - 同时，由于栈是单调递增的，栈顶柱子的左边界就是栈中前一个柱子。
4. **证明**：
   - 假设我们在位置 *i* 遇到一个比栈顶柱子 *j* 矮的柱子。由于栈是单调递增的，这意味着从 *j* 到 *i*−1 的所有柱子都比 *h*[*j*] 高。因此，我们可以确定 *r*[*j*]=*i*−1。
   - 同时，由于 *j* 是在栈顶的，这意味着 j*−1 位置的柱子比 *h*[*j*] 矮（否则 j* 早就被弹出了）。因此，我们可以确定l*[*j*]=*j。

通过上述逻辑，我们可以看到，对于每根柱子，我们都可以使用单调递增栈准确地确定其左右边界，并计算其对应的矩形面积。这确保了我们能够找到所有可能的矩形并计算其面积，从而找到最大的矩形面积。

这种证明方法更偏向于逻辑推理，而不是严格的数学证明。但它为我们提供了一个直观的理解，为什么单调递增栈在这个问题中是有效的。

#### 我没有懂i == heights.length这种情况

好的，我来解释一下。

在“柱状图中最大的矩形”这个问题中，我们使用单调栈来帮助我们找到每根柱子的左右边界。当我们遍历到某一根柱子时，如果这根柱子比栈顶的柱子矮，那么我们知道我们已经找到了栈顶柱子的右边界，可以计算以栈顶柱子为高的矩形面积。

但是，当我们遍历完所有的柱子后，栈中可能还有一些柱子没有被处理。这些柱子的右边界实际上是数组的末尾。为了处理这些柱子，我们可以在遍历完所有柱子后，再模拟添加一个高度为0的柱子到数组的末尾。这样，所有栈中剩余的柱子都会被弹出并处理。

这就是为什么我们会有`i == heights.length`这种情况。当`i`等于`heights.length`时，我们模拟处理一个高度为0的柱子，以确保栈中的所有柱子都被处理。

这是一个常见的技巧，用于确保栈中的所有元素都被处理。
