## 链表题目与解法

### 1. 基本操作

- 增 **插入节点**

- 删 **删除节点**

- 改 **反转链表**

- 查 **搜索节点**

- 改 **合并两个排序链表**

  *方法：双指针、迭代、递归*

### 2. 查找特定位置的节点

- **查找链表的中点**

- **查找链表的倒数第k个节点**

  *方法：双指针*

### 3. 环形链表

- **检测链表中是否有环**

- **找到环的起始位置**

  *方法：快慢指针*

### 4. 链表排序

- **排序链表**

  *方法：归并排序*

### 5. 链表的复制与比较

- **复制链表（特别是带有随机指针的链表）**

- **比较两个链表是否相同**

  *方法：哈希表、递归*

### 6. 多链表操作

- **合并k个已排序的链表**

  *方法：优先队列、递归、分治*

### 7. 链表的修改

- **重排链表**（例如: L0→L1→…→Ln-1→Ln 变为 L0→Ln→L1→Ln-1→L2→Ln-2→…）

  *方法：找中点、反转链表、合并链表*

### 8. 其他常见问题

- **链表的交点**

- **链表的回文结构检测**

  *方法：双指针、栈*
  
# 问题与解答

## 初始问题
我的错误答案！
为什么下列代码无法正确处理 `head = [7,7,7,7]`，结果仍然为 `[7,7,7,7]`？

```javascript
let q = new ListNode();
q.next = head;
while (q != null && q.next != null) {
    if (q.next.val == val) {
        q.next = q.next.next;
    } else {
        q = q.next;
    }
}
return head;

```
# 核心困惑

`q.next = q.next.next` 这个操作不算移动吗？

## 解答

### 1. 什么是“移动”？

在这段代码中，`q.next = q.next.next` 确实是一个“移动”的操作，但它移动的是`q.next`指向的节点，而不是`q`本身。

### 2. 为何代码无法正确处理连续相同值？

考虑链表 `[7,7,7,7]`：
- 初始时，`q` 是新创建的节点，`q.next` 指向第一个 `7`。
- 执行 `q.next = q.next.next` 会使 `q.next` 指向第二个 `7`。
- 但 `q` 仍然在新创建的节点位置。在下一次循环迭代中，`q.next` 仍指向第一个 `7`。

为了从链表中真正移除一个节点，需要：
1. 更新 `q.next` 使其指向要移除的节点的下一个节点。
2. 移动 `q` 本身。

原始代码在遇到连续的与 `val` 相等的节点时，只做了第一步，但忽略了第二步。因此，循环始终会检查链表的第一个节点。


#### 初始状态：
head  
 |  
 v  
7 -> 7 -> 7 -> 7  

#### 设定一个新的节点（虚拟节点）p，并且让 q 指向这个新节点。此时，p.next 指向链表的头部。
p/q  
 |  
 v  
null -> 7 -> 7 -> 7 -> 7  
 ^  
 |  
head

#### 第一次循环：
q.next 是第一个 7，与给定值相匹配，所以执行 q.next = q.next.next，跳过第一个 7，直接指向第二个 7。
p/q  
 |  
 v  
null -> 7 -> 7 -> 7  
 ^  
 |  
head

#### 第二次循环：
现在，q.next 依然是第一个 7，所以再次执行 q.next = q.next.next。但注意，这次它实际上是跳过第二个 7，直接指向第三个 7。
p/q  
 |  
 v  
null -> 7 -> 7  
 ^  
 |  
head

#### 第三次循环：
与之前相同，我们再次跳过一个 7，即第三个 7。
p/q  
 |  
 v  
null -> 7  
 ^  
 |  
head

#### 第四次循环：
此时，q.next 是最后一个 7，再次执行 q.next = q.next.next 会让 q.next 指向 null，也就是链表的末尾。
p/q  
 |  
 v  
null  
 ^  
 |  
head

现在链表为空，所有的 7 都被移除了。

所以，当我们最后返回 p.next，它实际上返回的是一个空链表，因为所有的 7 都被删除了。

## 所以head握着首节点只要首节点不发生改变那么这个head返回的链表就不变的原理是什么

假设head指向链表的第一个节点A，A指向B，B指向C。现在，如果你删除B（通过使A直接指向C），head仍然指向A。从head开始，你现在会看到A->C，因为B已经从链表中删除了。

但是在这整个过程中，head始终指向A，并没有变化。你改变的只是A后面的链表结构。

因此，你可以这样理解：尽管链表的内部结构可能因为增加、删除或修改节点而变化，但只要head仍然指向链表的第一个节点，head本身并不会因此而改变。这就是为什么当链表的内部结构发生改变时，只要其首节点不变，head的值（即它指向的内存地址）也不会变的原理。

[7,8,9,7,7,7]

console.log(q,p)

标准输出
[9] [0,8,9]
输出
[7,8,9]

## 结论

为了正确处理连续的相同值，当检查到 `q.next.val` 与 `val` 相同时，需要持续地跳过这些节点，直到找到一个不相等的节点为止。

正确的答案：
```javascript
var removeElements = function(head, val) {
let p = new ListNode()
p.next = head
let q = p
while(q!=null && q.next!=null){
    if(q.next.val==val){
        q.next = q.next.next
    }
    else{
        q = q.next
    }
}
return p.next
};
```
