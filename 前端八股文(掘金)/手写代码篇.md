#### Object.create() ---- 从一个旧对象“克隆”出一个新对象
`Object.create` 是一个JavaScript方法，用于创建一个新的对象，并为这个新对象设置一个指定的原型。这允许你基于一个已有的对象创建新的对象，而新对象会继承原对象的属性和方法。

**这有几个主要用途**：

1. **原型继承**：在经典的原型继承模式中，你可以使用 `Object.create` 来创建一个新对象，并将其原型设置为另一个对象。这样，新对象就可以继承原对象的属性和方法。

   ```
   javascriptCopy code
   const person = {
       sayHello: function() {
           console.log("Hello!");
       }
   };
   
   const john = Object.create(person);
   john.sayHello();  // 输出: Hello!
   ```

   在上面的例子中，`john` 对象继承了 `person` 对象的 `sayHello` 方法。

**如何手写呢**:
```javaScript
function create(obj) {
  function F() {}
  F.prototype = obj
  return new F()
}
```
1. **创建新对象**：JavaScript 创建一个空对象。
2. **设置原型**：新对象的原型被设置为 `F` 的 `prototype`，这里是 `obj`。
3. **返回新对象**：`new` 返回这个新对象。

#### 手写 instanceof 方法 ---- 从一个旧对象“克隆”出一个新对象
instanceof检查一个对象是否是某个构造函数的实例，通过不断查看对象的原型链来确定。如果在原型链上找到构造函数的原型，返回true，否则返回false。
   
```javaScript
function myInstanceof(left, right) {
  let proto = Object.getPrototypeOf(left), // 获取对象的原型
      prototype = right.prototype; // 获取构造函数的 prototype 对象

  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;

    proto = Object.getPrototypeOf(proto);
  }
}

```
所以两个变量的比较：
- 对象
- 函数
比较什么：对象的原型和函数关联的原型对象
看看对象的原型链上有没有函数关联的原型
这就是为什么我们说对象的原型链上有函数关联的原型对象：因为对象是通过使用new关键字与构造函数一起创建的，所以它的原型就是构造函数的prototype属性所指向的对象。
