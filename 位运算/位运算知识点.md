异或运算有以下几个关键特性：    
相同为0不同为1。
一个数异或它自己等于0（a ^ a = 0）。    
一个数异或0等于它自己（a ^ 0 = a）。     
异或运算满足交换律和结合律（a ^ b = b ^ a 和 a ^ (b ^ c) = (a ^ b) ^ c）。     
如果a ^ b = c，那么c ^ b = a。    

如何不使用临时变量交换a和b的值：    
第一步：a = a ^ b。此时，a变成了a和b的异或结果。    

第二步：b = a ^ b。现在，由于a是原始a和b的异或，所以用这个新a值异或b实际上等同于用原始a异或b异或b，根据上面的性质，b异或b等于0，那么原始的a异或0就等于原始的a，所以这一步之后b变成了原始的a。    

第三步：a = a ^ b。这时，a是原始的a和b的异或结果，b是原始的a。所以这一步实际上是原始的a异或b异或原始的a。根据异或运算的性质，原始的a异或原始的a等于0，剩下的就是原始的b。    

与运算（AND）    
与运算对两个位进行操作，只有当两个位都是1时，结果才为1。否则，结果为0。它遵循下面的规则：     

0 AND 0 = 0      
0 AND 1 = 0     
1 AND 0 = 0     
1 AND 1 = 1    


关于如何得到一个整数的二进制表示中最低位的1    

a & (~a + 1)   

在二进制加法中，当两个二进制数的同一位都是1时，这一位的和将会是0，并且会向上一位进位1。

例如，当我们对一个二进制数取反码然后加1以得到它的补码时，加1的过程是这样的：     

取反码意味着将所有的0变成1，将所有的1变成0。    

加1是在反码的基础上进行的。如果反码的最低位是0，加1将这个0变成1，没有进位产生。如果反码的最低位是1，加1将这个1变成0，并产生一个进位。这个进位会继续向高位传递，直到它加到一个是0的位上，那个位就会变成1，进位停止。     

按位或（bitwise OR）      
      
是一个基本的位操作。它对两个位模式或二进制数中对应的位进行逻辑或（OR）操作。当你对两个位执行按位或操作时，如果至少有一个位是1，那么结果位就是1，否则结果位是0。  


如何找到大于或等于某个给定整数 n 的最小的2的幂次方数。  

这通常涉及到一些位操作技巧，包括位移操作和按位或操作，来确定正确的幂次方数。这种计算在内存分配、哈希表的大小调整等方面非常有用，因为很多底层系统设计选择以2的幂次方来优化性能。

```code
function getNearestPowerOfTwo(n) {
  if (n <= 0) {
    return 1;
  }
  if ((n & -n) === n) {
    return n;
  }
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  return n + 1;
}
```


位移1位：
执行 n |= n >> 1，意味着 n 会被右移1位然后与原始的 n 进行按位或操作。     
结果将填充 n 最高位1的直接右侧的位为1。    
n:          0 1 0 0 0 0 0 0     
n >> 1:     0 0 1 0 0 0 0 0     
n |= n >> 1:  0 1 1 0 0 0 0 0     
位移2位：       
现在我们有两个连续的1（从最高位的1开始）。         
执行 n |= n >> 2，n 将被右移2位然后与之前的结果进行按位或操作。    
这会将最高位1及其右侧的3个位都填充为1。   
n:          0 1 1 0 0 0 0 0         
n >> 2:     0 0 0 1 1 0 0 0       
n |= n >> 2:  0 1 1 1 1 0 0 0    
位移4位：    
继续这个过程，n |= n >> 4 会将 n 右移4位然后与之前的结果进行按位或操作。    
这会将最高位1及其右侧的7个位都填充为1。    
n:          0 1 1 1 1 0 0 0      
n >> 4:     0 0 0 0 1 1 1 1     
n |= n >> 4:  0 1 1 1 1 1 1 1      
在这个例子中，因为我们只有8位，所以我们就完成了。但是如果有更多的位，你可以继续这个过程，每次位移的距离翻倍。最终，所有位于最高位1之右的位都会变成1。      

最后一步是加1：      

n:          0 1 1 1 1 1 1 1     
n + 1:      1 0 0 0 0 0 0 0       
这个结果 1 0 0 0 0 0 0 0 是大于或等于原始 n 的最小2的幂次方数。这个方法利用了位运算的性质，可以在对数时间内找到结果，这是非常高效的。      
