# 回溯我们主要有三种题型：组合，排列，子集
# 我们分别从理论与画图两种角度去分析

## 回溯算法与树形结构分析

回溯算法常常与树结构相关联，特别是当我们考虑组合、子集和排列这类问题时。

## 1. 组合III (combine)

### 核心思想
- 从n个数字中选择k个数字。

### 树形结构
- 树的每一层表示从n个数字中的一个选择。
- 从根到叶子的路径表示一个完整的组合。

### 去重
- 使用 `i=start` 确保在同一层不重复选择相同的数字。
  
```javaScript
for(let i=start;i<=9;i++){
        sum+=i
        res.push(i)
        dfs(i+1,sum,res)
        res.pop()
        sum-=i
    }
```

## 2. 子集II (subsetsWithDup)

### 核心思想
- 生成所有可能的子集，但不能有重复的子集。

### 树形结构
- 树的每一层基于前一层的选择进行构建，代表新的子集。
- 从根到任意节点的路径都是一个有效子集。

### 去重
- 已经排序的数组帮助我们通过检查当前数字与前一个数字是否相同来去重。

```javaScript
if(i>start&&nums[i-1]==nums[i]) continue
```

## 3. 排列II (permuteUnique)

### 核心思想
- 生成所有可能的排列，但不能有重复的排列。

### 树形结构
- 树的每一层都表示一个选择。
- 从根到叶子的路径表示一个完整的排列。

### 去重
- 使用 `visited` 数组跟踪已被选择的数字。
- 检查当前数字是否与前一个数字相同以及前一个数字是否未被使用来去重。

```javaScript
if(i>0&&nums[i-1]==nums[i]&&!visited.includes(i-1)) continue
if(visited.includes(i)) continue
```

## 总结

回溯算法可以视为一种在解空间树上进行的深度优先搜索。当我们寻找一个解时，我们遍历树的每一个节点。当某路径不能继续或违反条件时，我们回溯到上一节点并尝试其他可能的子节点。结合树形结构可以帮助我们更直观地理解和调试回溯算法。



